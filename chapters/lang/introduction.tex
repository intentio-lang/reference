\chapter{Introduction}

Intentio is domain specific, imperative programming language oriented for processing textual data. Intentio provides goal-oriented execution, generators, strong dynamic typing with optional type annotations, and a rich set of primitive data types, including Unicode strings, lists, arrays, maps, sets, arbitrary and fixed precision integers, and floating-point numbers. Intentio tries to incorporate ideas of the Icon\cite{TheIconProgrammingLanguage} programming language into modern programming patterns.

This part defines the syntax of Intentio language and informal abstract semantics for the meaning of such programs. We leave as implementation detail how Intentio programs are manipulated, interpreted, compiled, etc. This includes all steps from source code to running program, programming environments and error messages. This also means that this document do not describe the reference compiler for Intentio language - \emph{intentioc}\cite{intentioc}.

\section{Notation}

Throughout this document a BNF-based notational syntax is used to describe lexical structure and grammar:

\[
nonterminal ::= \texttt{term} | \texttt{another} \texttt{term}+
nonterm2    ::= nonterminal*
\]

Following conventions are used for presenting productions syntax:

\begin{center}
  \begin{tabular}[t]{rl}
    \((pattern)\)                & grouping \\
    \([pattern]\)                & optional \\
    \(pattern*\)                 & zero or more repetitions \\
    \(pattern+\)                 & one or more repetitions \\
    \(pattern_a | pattern_b\)    & choice \\
    \(\texttt{token}\)           & terminal symbol (in fixed-width font)
  \end{tabular}
\end{center}

\subsubsection{Unicode productions}

A few productions in Intentio's grammar permit Unicode\cite{Unicode6} code points outside the ASCII range. These productions are defined in terms of character properties specified in the Unicode standard, rather than in terms of ASCII-range code points. Intentio compilers are expected to make use of new versions of Unicode as they are made available.


\section{Phase distinction}

Intentio's semantics obey a \emph{phase distinction} between compile-time and run-time\footnote{In interpreter environments, compile-time would consist of syntactic analysis and linting.}. Semantic rules that have a static interpretation govern the success or failure of compilation, while semantic rules that have a dynamic interpretation govern the behaviour of the program at run-time.

\section{Program Structure}

An Intentio program is structured syntactically and semantically into five abstract levels.

\begin{enumerate}
  \item At the topmost of each Intentio program or library is an \emph{assembly}. In compiled environments assembly is an unit of compilation, while in interpreted environments assembly is a whole set of loaded modules.
  \item At the topmost of each assembly is a set of \emph{modules}. Modules provide a way to control namespaces and to re-use software in larger programs. A particular source code file of Intentio program consists of one or more modules.
  \item The top level of each module is a set of \emph{item declarations}. An item is a component of module.
\end{enumerate}

This document proceeds bottom-up with respect to Intentio's syntactic structure.

\section{Values, Types and Evaluation State}

% TODO:


\section{Namespaces}

% TODO:

TODO MOVE TO CHAPTER ABOUT ITEMS AND ASSEMBLIES: Modules and items are entirely determined at compile-time, remain fixed during execution, and may reside in read-only memory. This limitation does not apply to assemblies, it is allowed to provide mechanisms to dynamically compile, load and unload modules at run-time.

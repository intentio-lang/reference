\chapter{Introduction}

Intentio is domain specific, imperative programming language oriented for processing textual data. Intentio provides goal-oriented execution, strong dynamic typing with optional type annotations, and a set of primitive data types, including Unicode strings, fixed precision integers, and floating-point numbers. Intentio tries to incorporate ideas of the Icon\cite{TheIconProgrammingLanguage} programming language into modern programming patterns.

% TODO: "rich set of types": arbitrary precision integers, lists, maps, sets

This document defines the syntax of Intentio language and informal abstract semantics for the meaning of such programs. We leave as implementation detail how Intentio programs are manipulated, interpreted, compiled, etc. This includes all steps from source code to running program, programming environments and error messages. This also means that this document does not describe the Intentio standard library nor the reference compiler for Intentio language - \emph{intentioc}\cite{intentioc}.


\section{Notational Conventions}

\subsection*{Grammar}

Throughout this document a BNF-style notational syntax is used to describe lexical structure and grammar:

\begin{bnf}
  nonterminal \eq \term{terminal} \gor alternative
\end{bnf}

Following conventions are used for presenting productions syntax:

\begin{bnfutils}
\begin{center}
\begin{tabular}[t]{ll}
  \(\term{token}\)        & terminal symbol \\
  \(rule\)                & nonterminal symbol (in italic font) \\
  \((pat)\)               & grouping \\
  \(\gtry{pat}\)          & optional (0 or 1 times) \\
  \(\gmanya{pat}\)        & repetition (1 to \(n\) times) \\
  \(\gmany{pat}\)         & optional repetition (0 to \(n\) times) \\
  \(pat_1 \ pat_2\)       & concatenation \\
  \(pat_1 \gor pat_2\)    & alternative \\
  \(\gdiff{pat}{pat'}\)   & difference (symbols generated by \(pat\) \\
                          & except those generated by \(pat'\))
\end{tabular}
\end{center}
\end{bnfutils}

\subsubsection*{Parametrized productions}

Some productions in Intentio's grammar (like raw string literals) cannot be expressed using context-free grammar with a finite number of productions. In order to reduce the need of falling back to natural language, a concept of \emph{parametrized productions} is used throughout this document.

A production \(A(x_1, x_2, ..., x_n) \rightarrow B\), parametrized over arguments \(x_1, x_2, ..., x_n\), defines different production for each combination of its arguments.

\subsubsection*{Unicode productions}

A few productions in Intentio's grammar permit Unicode\cite{Unicode} code points outside the ASCII range. These productions are defined in terms of character properties specified in the Unicode standard, rather than in terms of ASCII-range code points. Intentio compilers are expected to make use of new versions of Unicode as they are made available.

\subsection*{Source code listings}

Examples of Intentio program fragments are given in fixed-width font:

\begin{lstlisting}
fun main() {
  x = 4; y = 3;
  println("sum = " + str(x + y));
}
\end{lstlisting}


\section{Compile-time and Run-time}

Intentio's semantics obey a \emph{phase distinction} between compile-time\index{compile-time} and run-time\index{run-time}\footnote{In interpreter environments, compile-time would consist of syntactic analysis and linting.}. Semantic rules that have a static interpretation govern the success or failure of compilation, while semantic rules that have a dynamic interpretation govern the behaviour of the program at run-time.


\section{Program Structure}

An Intentio program is structured syntactically and semantically into five abstract levels:

\begin{enumerate}
  \item At the topmost of each Intentio program or library is an \emph{assembly}. In compiled environments assembly is a unit of compilation, while in interpreted environments assembly is a whole set of loaded modules.
  \item At the topmost of each assembly is a set of \emph{modules}. Modules provide a way to control namespaces and to re-use software in larger programs. A particular source code file of Intentio program consists of one module. Module structure is flat, there is no concept of the submodule.
  \item The top level of each module is a set of \emph{item declarations}. An item is a component of the module, such as a function, type definition or constant variable.
  \item Items which contain the real, executable code are built of \emph{statements} and \emph{expressions}. Statements express sequential, side-effect-full actions to carry out. Expression denotes how to evaluate a \emph{term} and evaluating expression returns a \emph{result}.
  \item At the bottom level is Intentio's \emph{lexical structure}. It describes how to build tokens - the most basic blocks of program's source code from sequences of characters in the source file.
\end{enumerate}


\section{Values, Types, Terms and Results}

A \emph{value}\index{value} is a representation of some entity which can be manipulated by a program. A \emph{type}\index{type} is a tag that defines the interpretation of value representation. Values and types are not mixed in Intentio. Values by itself are untyped, value's type is required to perform any kind of operation on value.

A \((value, type)\) pair is called a \emph{term}\index{term}. Terms represent data yielded from evaluating expressions. Intentio is \emph{strongly typed} so implicit type conversions do not exist in the language, but it is not prohibited to include casts in expressions semantics (thus \lstinline{5 + 4.0} runs successfully).

Evaluating expressions may either succeed or fail. A tagged union of successfully evaluated result or failure with information describing what failed is called a \emph{result}\index{result}. Terms and results are the basic blocks of representing information in Intentio.

Following Haskell-style code listing describes relationships between these concepts:

\begin{lstlisting}[language=Haskell]
  data Value = ...
  data Type = ...

  newtype Term = (Value, Type)

  data Result = Succ Term
              | Fail Term
\end{lstlisting}


\section{Namespaces}

There are three distinct namespaces in Intentio:

\begin{description}
  \item [Item namespace\index{namespace!item namespace}] Consists item and variable names.
  \item [Module namespace\index{namespace!module namespace}] Consists of module names and import renames.
  \item [Type namespace\index{namespace!type namespace}] Consists of type names.
\end{description}

There are no constraints on names belonging to the particular namespace, therefore it is possible for name \texttt{Int} to simultaneously denote an item/variable, module and type.

\section{Intentio source file}

\begin{bnf}
  \gd{file} \eq \gtry{\term{\gp{UTF8BOM}}} \\
            & & \gp{module} \\
  \\
  \term{\gd{UTF8BOM}} \eq \term{\textbackslash u\{EFBBBF\}} \gcomm{UTF-8 Byte Order Mark}
\end{bnf}

An Intentio source file describes a single module, the name of which is defined by source file name. Source files have extension \lstinline{.ieo}. File name \lstinline{example.ieo} defines module named \lstinline{example}.

\begin{bnfutils}
Intentio source files must always be encoded in UTF8. The optional UTF8 byte order mark (lexical \term{UTF8BOM} production) can only occur at the beginning of the file and must be ignored by the parser.
\end{bnfutils}
